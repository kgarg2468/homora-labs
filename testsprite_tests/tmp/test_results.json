[
  {
    "projectId": "dc9efb19-de94-4df1-b2bf-f15a4d958f49",
    "testId": "d18ca1c4-58f4-4b9b-bd19-db58da526adc",
    "userId": "54d89418-5031-70c3-e08b-f864479dfa96",
    "title": "TC006-Conversation Message Edit and Branching",
    "description": "Verify that editing a user message and regenerating a response creates a new conversation branch with proper branch markers and switch prompts.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the project 'fds' to access its conversations/chat (click the project card).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/main/div/div[1]/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'fds' project by clicking its project card (element index 131) to access conversations/chat.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/main/div/div[1]/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open/start a new conversation by sending a question in the chat input (create a conversation to later edit the user message).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/header/div[1]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[2]/div/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Summarize the document \\'09_Commercial_Lease_Agreement.txt\\' and list any lease term lengths mentioned.')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/header/div[2]/a/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Send the question to start the conversation by clicking the send button, then wait for the AI response to load.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[3]/div/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Return to the project/conversations UI (click the back/home link) to reopen the 'fds' project and continue the branching test by locating the conversation with the unsent message.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/header/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the back/home link (element index 1236) to return from Settings to the projects/conversation view so the branching test can continue.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/header/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'fds' project by clicking its project card anchor (use element index 1827) to access its conversations/chat.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/main/div/div[1]/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'fds' project by clicking its project card (element index 1827) to load the project/conversation view so the branching test can continue.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/main/div/div[1]/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Start a new conversation by clicking 'New Conversation', input the test question into the chat textarea, and send it (press Enter) so the AI response can be generated.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/header/div[1]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[2]/div/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Summarize the document \\'09_Commercial_Lease_Agreement.txt\\' and list any lease term lengths mentioned.')\n        \n        # -> Open the edit UI for the user's message by clicking the message's Edit icon so the message content can be modified.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[1]/div/div[2]/div[1]/svg').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the user-message edit UI by clicking the message's Edit button (index 2821). Then modify the message and trigger regeneration (next actions after the edit UI is open).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Replace the user message text in the open edit textarea with an updated prompt and click 'Save & regenerate' to trigger AI response regeneration (this should create a new conversation branch).\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[2]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Summarize the document \\'09_Commercial_Lease_Agreement.txt\\' and list any lease term lengths mentioned, including the durations of any renewal options and the initial term dates.')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the message edit UI, replace the message text with the updated prompt, and click 'Save & regenerate' to trigger AI response regeneration (should create a new conversation branch).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Replace the user message text with the updated prompt and click 'Save & regenerate' to trigger AI response regeneration (should create a new conversation branch). Then wait for the assistant response to appear so branching markers can be checked.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[2]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Summarize the document \\'09_Commercial_Lease_Agreement.txt\\' and list any lease term lengths mentioned, including the durations of any renewal options and the initial term dates.')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the user-message edit UI by clicking the Edit button for the user's message so the message can be modified and then saved with 'Save & regenerate'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Replace the user message text in textarea (index 3364), click Save & regenerate (index 3363) to create a new branch, wait for the assistant response, then extract the page to confirm branch markers and branch-switch UI.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div[1]/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[2]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Summarize the document \\'09_Commercial_Lease_Agreement.txt\\' and list any lease term lengths mentioned, including the durations of any renewal options and the initial term dates.')\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the message edit UI if needed, replace the user message text with the updated prompt, and click 'Save & regenerate' to create a new conversation branch.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the message edit UI (if not already), replace the user message text, trigger Save & regenerate to create a new branch, wait for assistant response, then extract the page content to confirm branch markers and branch-switch UI.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[2]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Summarize the document \\'09_Commercial_Lease_Agreement.txt\\' and list any lease term lengths mentioned, including the durations of any renewal options and the initial term dates.')\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d89418-5031-70c3-e08b-f864479dfa96/17705077374976//tmp/test_task/result.webm",
    "created": "2026-02-07T23:28:04.292Z",
    "modified": "2026-02-07T23:42:17.653Z"
  },
  {
    "projectId": "dc9efb19-de94-4df1-b2bf-f15a4d958f49",
    "testId": "8eb21184-c562-4734-afed-4814586a6f5a",
    "userId": "54d89418-5031-70c3-e08b-f864479dfa96",
    "title": "TC007-Soft Delete, Restore, and Purge Conversations",
    "description": "Verify conversation lifecycle features including soft delete to trash, restore from trash, and permanent purge functionality.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the 'test' project to access its conversations and conversation actions (soft delete / restore / purge).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/main/div/div[1]/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'test' project by clicking its project card (use element index 99).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/main/div/div[1]/div[2]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Create a new conversation by entering a question into the page textarea and send it so a conversation appears in the conversation list.\n        frame = context.pages[-1]\n        # Input text\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[2]/div/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test conversation for lifecycle: please respond with a short confirmation message.')\n        \n        # -> Open the conversation message container to reveal conversation actions (options menu) so the conversation can be soft-deleted (move to Trash).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/div[1]/div/div[1]/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the conversation's options (Edit/overflow menu) to reveal the 'Move to Trash' / delete action so the conversation can be soft-deleted (move to Trash).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[3]/div/div[1]/div/div[1]/div/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the 'Current Session' dropdown/menu (session-level actions) to reveal the 'Move to Trash' / delete option so the conversation can be soft-deleted.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[3]/div/header/div[1]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Soft-delete the selected conversation by clicking its 'Move to trash' control (element index 853) in the Current Session menu.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[3]/div/header/div[1]/div/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Trash view by clicking the left sidebar 'Trash' link (element index 524) to verify the conversation appears in Trash.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Trash view (left sidebar) to display trashed conversations and verify the deleted conversation is present there.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Restore' button for the trashed conversation (element index 1100) to restore it to the active conversation list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/section/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Restore' button for the trashed conversation (element 1100), wait for the UI to update, then navigate back to the project (Back to Project link element 1043) to verify the conversation appears in the active conversation list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/section/div/div[1]/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div[1]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate back to the project active view to check whether the trashed item was restored. If restored, then re-soft-delete and permanently purge (Delete Permanently) and verify purge. Immediate action: Click 'Back to Project' (element 1043) to inspect the active list.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div[1]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Trash view to inspect trashed items and confirm whether the conversation remains in Trash or was restored to the active list (click 'Trash' link, element index 1434).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[1]/div/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Trash view and inspect trashed items to determine whether the conversation remains in Trash or was restored; if present, prepare to Restore or Purge as required.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        ```\n        try:\n            await expect(frame.locator('text=Conversation permanently deleted').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Expected the conversation to be permanently purged from Trash and become irrecoverable, but the confirmation text 'Conversation permanently deleted' was not found. The test was verifying permanent deletion (purge) of the conversation.\")\n        ```\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Summary of verification run (stop requested):\n\nWhat was tested:\n- Soft delete (Move to Trash): Executed and visually verified. The created conversation was moved to Trash and appeared in the Trash view.\n- Restore from Trash: 'Restore' was clicked twice. UI did not clearly confirm the restore â€” the Trash still showed entries previously and the active project view showed no conversations. Restore success is unconfirmed.\n- Permanent purge (Delete Permanently): Not performed during this run.\n\nCurrent state:\n- Soft-delete: SUCCESS (conversation moved to Trash and visible in Trash view).\n- Restore: UNKNOWN (restore action was triggered twice but page state did not reflect a clear change; active list empty and Trash state ambiguous). Further verification is required.\n- Permanent purge: NOT DONE.\n\nNotes and recommendations to continue testing (if desired):\n1) Wait for UI stabilization or reload the project view and re-open Trash to confirm whether the restore completed. If restore still not apparent, attempt a single Restore click and wait for a clear UI update.\n2) After successful restore verification, re-soft-delete the conversation and then use the 'Delete Permanently' control to purge; confirm item no longer appears in Trash nor in active list.\n3) If clicks continue to have no effect, check application logs or console for errors and retry when the SPA is responsive.\n\nTest run ended on user request. The lifecycle is partially verified: soft-delete verified; restore and purge remain to be confirmed.\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d89418-5031-70c3-e08b-f864479dfa96/1770507319387861//tmp/test_task/result.webm",
    "created": "2026-02-07T23:28:04.296Z",
    "modified": "2026-02-07T23:35:19.525Z"
  },
  {
    "projectId": "dc9efb19-de94-4df1-b2bf-f15a4d958f49",
    "testId": "5b0d6a0a-68f0-47e6-9f51-c3211b621642",
    "userId": "54d89418-5031-70c3-e08b-f864479dfa96",
    "title": "TC008-Soft Delete, Restore, and Purge Documents",
    "description": "Verify document lifecycle features including soft delete to trash, restore from trash, and permanent purge functionality.",
    "code": "import asyncio\nfrom playwright import async_api\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n        # -> Navigate to http://localhost:3000\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the New Project flow by clicking the 'New Project' button to create a test project.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/header/div/div/div[2]/a[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the project card (project titled '1' with 2 documents) to view its documents by clicking the project link.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/main/div/div[1]/div[2]/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select the first document in the sidebar (Final Paper - Google Docs.pdf) to open its item and reveal document action controls so it can be soft-deleted (move to Trash).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[1]/div/div[2]/div[3]/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the open PDF viewer modal so the document action controls (delete/Trash) in the sidebar become accessible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[2]/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Select the 'Final Paper - Google Docs.pdf' document in the sidebar to reveal document action controls (so it can be soft-deleted).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[2]/div[3]/div/div[1]/div/div[1]/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the PDF viewer modal so document action controls in the sidebar become accessible.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[2]/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the document's action/menu (more options) in the sidebar for 'Final Paper - Google Docs.pdf' to access the soft-delete (Move to Trash) action.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[2]/div[3]/div/div[1]/div/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Move to Trash' for 'Final Paper - Google Docs.pdf' to soft-delete the document (use element index 811).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[2]/div[3]/div/div[1]/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Trash view to verify whether 'Final Paper - Google Docs.pdf' moved there after the Move to Trash action.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Trash view and inspect its document list to verify whether the previously clicked 'Move to Trash' action moved the document into Trash.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Restore' button for 'Final Paper - Google Docs.pdf' in Trash to restore it to the active documents list (use element index 999).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/section/div/div/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Trash view to refresh the page state and locate the document's Restore button (then attempt restore). Immediate action: click the 'Trash' link to load Trash list (index=1082).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[1]/div/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open/refresh the Trash view, inspect the Trash list for the deleted document, and attempt to restore it.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Restore' button for 'Final Paper - Google Docs.pdf' in Trash to restore it to the active documents list (use element index 1281).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[2]/section/div/div/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click the 'Restore' button for 'Final Paper - Google Docs.pdf' (index 1281) to attempt restoring it from Trash; then verify by checking the active document list (navigate back to project view).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[2]/section/div/div/div[2]/button[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Verify whether the document was restored by returning to the project active documents view (click 'Back to Project') and inspect the active document list for the restored document.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[1]/div[1]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Click 'Back to Project' to open the active documents list and verify whether the document was restored (use element index 1315).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div[1]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the document action/menu for 'Final Paper - Google Docs.pdf' (click element index 1821) so 'Move to Trash' can be selected and the document can be soft-deleted again in order to test permanent purge.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[1]/div/div[2]/div[3]/div/div[1]/div/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Soft-delete the document again by clicking the 'Move to Trash' option in the document action menu (index 1888) to prepare for permanent purge.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[2]/div[3]/div/div[1]/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Trash view and locate the 'Final Paper - Google Docs.pdf' entry so it can be permanently deleted (Delete Permanently).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the Trash view and inspect the list to confirm the document is present for permanent deletion, then perform the permanent purge.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[3]/a[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Navigate back to the project's active documents view to verify whether the document is currently active or was soft-deleted (second attempt). If active, attempt Move to Trash again; if in Trash, perform Delete Permanently and verify removal.\n        await page.goto(\"http://localhost:3000/projects/49b909e9-9af9-4794-943b-e9d494493198\", wait_until=\"commit\", timeout=10000)\n        \n        # -> Open the document action/menu for the visible document 'Environmental Project Report.pdf' so 'Move to Trash' can be selected.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div/div/div[1]/div/div[2]/div[3]/div/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the open PDF viewer modal so document action controls in the sidebar become accessible (click button index=2311).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[2]/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the document action/menu for 'Environmental Project Report.pdf' so the 'Move to Trash' option can be selected (click element index 2170).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[2]/div[3]/div/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the open PDF viewer modal so the document action controls in the sidebar become accessible for soft-delete/purge actions.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[2]/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the document action/menu for 'Environmental Project Report.pdf' so the 'Move to Trash' option is available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[2]/div[3]/div/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the open PDF viewer modal so the document action controls in the sidebar become accessible for 'Environmental Project Report.pdf'.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[2]/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the document action/menu or select the sidebar entry for 'Environmental Project Report.pdf' so the 'Move to Trash' option becomes available (click element index 2170).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[2]/div[3]/div/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the open PDF viewer modal so sidebar document action controls become accessible (click Close modal button index 2533).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[2]/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the document action/menu for 'Environmental Project Report.pdf' so the 'Move to Trash' option is revealed (click element index 2170).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[2]/div[3]/div/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the open PDF viewer modal so the sidebar action menu becomes accessible for 'Environmental Project Report.pdf' (click Close modal).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[2]/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Open the document action/menu for 'Environmental Project Report.pdf' so the 'Move to Trash' option becomes available.\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div/div[1]/div/div[2]/div[3]/div/div/div/div[1]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        # -> Close the PDF viewer modal so sidebar document action controls become accessible for further lifecycle steps (soft-delete Environmental).\n        frame = context.pages[-1]\n        # Click element\n        elem = frame.locator('xpath=html/body/div[1]/div[2]/div[2]/div[1]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54d89418-5031-70c3-e08b-f864479dfa96/1770507712482861//tmp/test_task/result.webm",
    "created": "2026-02-07T23:28:04.301Z",
    "modified": "2026-02-07T23:41:52.658Z"
  }
]
